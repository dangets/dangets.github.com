<!DOCTYPE html>
<html>
    <head>
        <style type="text/css">
            div#vis text {
                fill: gray;
                font-family: Helvetica, sans-serif;
                font-size: 12px;
            }

            div#vis .contextArea {
                fill: #6d7b8d;
            }

            .brush .extent {
                stroke: #fff;
                fill-opacity: .125;
                shape-rendering: crispEdges;
            }

            .axis path, .axis line {
                fill: none;
                stroke: #000;
                shape-rendering: crispEdges;
            }
        </style>
        <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js"></script>

        <script type="text/javascript" src="dg/dg.js"></script>
        <script type="text/javascript" src="dg/Accumulator.js"></script>
    </head>

    <body>

        <div id="vis">
        </div>

        <script type="text/javascript">
            var visWidth = 900;
            var visHeight = 500;

            var focusMargin = { top: 15, right: 140, bottom: 40, left: 20 };
            var contextMargin = { top: 10, right: 140, bottom: 20, left: 20 };

            var contextWidth = visWidth - (contextMargin.left + contextMargin.right);
            var contextHeight = 80;

            var focusWidth = visWidth - (focusMargin.left + focusMargin.right);
            var focusHeight = visHeight - focusMargin.top - focusMargin.bottom -
                    contextHeight - contextMargin.top - contextMargin.bottom;

            var focusCorner = new Object();
            focusCorner.x0 = focusMargin.left;
            focusCorner.y0 = focusMargin.top;
            focusCorner.x1 = focusCorner.x0 + focusWidth;
            focusCorner.y1 = focusCorner.y0 + focusHeight;

            var contextCorner = new Object();
            contextCorner.x0 = contextMargin.left;
            contextCorner.y0 = focusCorner.y1 + focusMargin.bottom + contextMargin.top;
            contextCorner.x1 = contextCorner.x0 + contextWidth;
            contextCorner.y1 = contextCorner.y0 + contextHeight;

            // setup the x axis scales and axes
            var focus_xScale = d3.time.scale().range([0, focusWidth]);
            var context_xScale = d3.time.scale().range([0, contextWidth]);

            var focus_xAxis = d3.svg.axis().scale(focus_xScale).orient("bottom");
            var context_xAxis = d3.svg.axis().scale(context_xScale).orient("bottom");

            var brush = d3.svg.brush()
                .x(context_xScale)
                .on("brush", brushMove);

            // construct the svg canvas and groups
            var vis = d3.select("#vis")
                .append("svg:svg")
                .attr("width", visWidth)
                .attr("height", visHeight);

            vis.append("defs").append("clipPath")
                .attr("id", "focusClip")
                .append("rect")
                .attr("width", focusWidth)
                .attr("height", focusHeight);

            ///////////////////////////////////////////////////////////
            // focus svg elements
            var focus = vis.append("svg:g")
                .attr("id", "focus")
                .on("mousemove", focusOnMouseMove)
                .on("mouseout", focusOnMouseOut)
                .attr("transform", "translate(" + focusCorner.x0 + ", " + focusCorner.y0 + ")");

            // need to draw a background rectangle for the mousemove function to register
            focus.append("svg:rect")
                .attr("id", "focusBackground")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", focusWidth)
                .attr("height", focusHeight)
                .attr("fill", "white");

            focus.append("svg:g")
                .attr("class", "x axis")
                .attr("id", "focus_xAxis")
                .attr("transform", "translate(0," + focusHeight + ")");

            var focusMouseCircles;

            ///////////////////////////////////////////////////////////
            // context svg elements
            var context = vis.append("svg:g")
                .attr("id", "context")
                .attr("transform", "translate(" + contextCorner.x0 + ", " + contextCorner.y0 + ")");

            context.append("svg:g")
                .attr("class", "x axis")
                .attr("id", "context_xAxis")
                .attr("transform", "translate(0," + contextHeight + ")");


            var fieldInfo = new Object();   // {fieldName: {type: X, max: X, min: X}}
            var curDataset = null;          // [{field1: val, field2: val, ...}]

            var focusFields = [     // TODO: hardcoded field names
                "Current Assets",
                "Cash",
                "Accounts Receivable",
                "Inventory",
                "Current Liabilities",
            ];
            var focusPlots = new Object();  // {fieldName: Plot}
            var contextField = "Current Assets";
            var contextPlot = null;

            function setCurrentDataset(name, dfieldInfo, data) {
                processDataSet(dfieldInfo, data);
                curDataset = data;
                fieldInfo = dfieldInfo;

                setupXAxis();
                setupPlots();

                draw();
            }

            // sets up unformatted data to be used as a dataset
            //  assumes a list of records that all have the same attributes, and values as strings
            //  NOTE: this internally alters the passed in 'data' (impure)
            function preprocessNamedData(data) {
                if (data == null) {
                    console.error("null data passed into convertNamedData");
                    return null;
                }

                // get the metadata for each field
                var fieldInfo = new Object();
                var row0 = data[0];
                for (var fieldName in row0) {
                    fieldVal = row0[fieldName];
                    fieldInfo[fieldName] = new Object();
                    fieldInfo[fieldName]["type"] = dg.guessDataType(fieldVal);
                }

                // convert all of the data to the guessed type
                for (var row_i in data) {
                    for (var fieldName in data[row_i]) {
                        type = fieldInfo[fieldName]["type"];
                        fieldVal = type.parse(data[row_i][fieldName]);
                        data[row_i][fieldName] = fieldVal;
                    }
                }

                return fieldInfo;
            }

            // using fieldInfo, get some more metadata about each of the data fields
            function processDataSet(fieldInfo, data) {
                // find the min and max of each field
                accumulators = new Object();
                for (var fieldName in fieldInfo) {
                    accumulators[fieldName] = new Object();
                    accumulators[fieldName]["min"] = new AccumulatorGenericMin();
                    accumulators[fieldName]["max"] = new AccumulatorGenericMax();
                }

                for (var row in data) {
                    // these operations could all be done in parallel - *sigh*
                    for (var fieldName in data[row]) {
                        for (var acc in accumulators[fieldName]) {
                            var val = data[row][fieldName];
                            accumulators[fieldName][acc].accumulate(val);
                        }
                    }
                }

                //console.debug(accumulators);
                // assign the accumulators' values onto the fieldInfo structure
                for (var fieldName in fieldInfo) {
                    for (var acc in accumulators[fieldName]) {
                        fieldInfo[fieldName][acc] = accumulators[fieldName][acc].getValue();
                    }
                }
            }


            function setupXAxis() {
                //console.debug(fieldInfo);

                // get the timeline extents for use in all plots
                var dateField = fieldInfo["Date"];      // TODO: hardcoded fieldname
                if (dateField == undefined) {
                    console.error("field 'Date' is undefined");
                    return;
                }

                var minDate = dateField["min"];
                var maxDate = dateField["max"];
                if (minDate == undefined || maxDate == undefined) {
                    console.error("dateField 'min' and/or 'max' is undefined");
                    return;
                }
                focus_xScale.domain([minDate, maxDate]);
                context_xScale.domain([minDate, maxDate]);
            }


            function _setupGenericPlot(fieldName, plotHeight) {
                var minVal = Math.min(0, fieldInfo[fieldName]["min"]);
                var maxVal = fieldInfo[fieldName]["max"];

                var plot = new Object();
                plot.yScale = d3.scale.linear()
                    .domain([minVal, maxVal])
                    .range([plotHeight, 0]);
                return plot;
            }

            function _setupFocusPlot(fieldName, plotHeight, yTranslation) {
                var plot = _setupGenericPlot(fieldName, plotHeight);

                plot.y0 = yTranslation;

                plot.area = d3.svg.area()
                    .interpolate("linear")
                    .x(function(d) { return focus_xScale(d["Date"]); })
                    .y0(function() { return plot.yScale(0); })
                    .y1(function(d) { return plot.yScale(d[fieldName]); });

                plot.g = focus.append("svg:g")
                    .attr("transform", "translate(0, " + yTranslation + ")");

                plot.g.path = plot.g.append("svg:path")
                    .attr("class", "focusArea")
                    .attr("fill", "steelblue")
                    .attr("clip-path", "url(#focusClip)");

                var _yExtent = plot.yScale.range();
                var _yMid = (_yExtent[0] + _yExtent[1]) / 2;
                plot.g.label = plot.g.append("svg:text")
                    .attr("class", "focusLabel")
                    .attr("x", focus_xScale.range()[1])
                    .attr("y", _yMid)
                    .attr("dx", 5)         // padding right
                    .attr("dy", ".35em")    // vertical-align middle
                    .text(fieldName);

                return plot;
            }

            function _setupContextPlot() {
                var plot = _setupGenericPlot(contextField, contextHeight);

                plot.area = d3.svg.area()
                    .interpolate("linear")
                    .x(function(d) { return context_xScale(d["Date"]); })
                    .y0(function() { return plot.yScale(0); })
                    .y1(function(d) { return plot.yScale(d[contextField]); });

                plot.g = context.append("svg:g")
                    .attr("class", "contextArea")
                    .attr("id", "context");
                plot.g.append("svg:path");

                return plot;
            }


            function setupPlots() {
                var numPlots = focusFields.length;

                var plotYMargin = 10;
                var plotHeight;
                var plotWidth;

                plotHeight = Math.floor(focusHeight / numPlots);
                plotHeight -= plotYMargin;
                plotWidth = focusWidth;

                //console.debug("plotHeight: " + plotHeight);
                //console.debug("plotWidth: " + plotWidth);

                // setup focus plots (order is set by focusFields)
                var curPlot = 0;
                for (var name_i in focusFields) {
                    var fieldName = focusFields[name_i];
                    var yTranslation = curPlot * (plotHeight + plotYMargin);
                    var plot = _setupFocusPlot(fieldName, plotHeight, yTranslation);
                    focusPlots[fieldName] = plot;
                    curPlot += 1;
                }

                // setup context plot
                contextPlot = _setupContextPlot();

                // setup brush
                d3.select("#contextBrush").remove();
                context.append("g")
                    .attr("class", "x brush")
                    .attr("id", "contextBrush")
                    .call(brush)
                    .selectAll("rect")
                    .attr("y", -6)
                    .attr("height", contextHeight + 7);

                // re-append the yFocus line to bring it to front
                d3.select("#focus_yMouseLine").remove();
                focus.append("svg:line")
                    .attr("id", "focus_yMouseLine")
                    .attr("stroke", "black")
                    .attr("shape-rendering", "crispEdges")
                    .attr("y1", 0)
                    .attr("y2", focusHeight);

                d3.select("#focus_yMouseLineText").remove();
                focus.append("svg:text")
                    .attr("id", "focus_yMouseLineText")
                    .attr("y", -2);

                //focusMouseCircles = focus.selectAll(".focusMouseCircles")
                //    .data(focusFields);

                //focusMouseCircles.remove();
                //focusMouseCircles.enter()
                //    .append("circle")
                //    .attr("class", "focusMouseCircle")
                //    .attr("cx", 0)
                //    .attr("cy", function(d) { return focusPlots[d].y0; })
                //    .attr("r", 2);
            }


            function draw() {
                //console.debug("draw()");

                // draw the focus plots
                for (var fieldName_i in focusFields) {
                    var fieldName = focusFields[fieldName_i];

                    var plot = focusPlots[fieldName];
                    plot.g.select("path")
                        .attr("d", plot.area(curDataset));
                }

                // draw the context plot
                contextPlot.g.select("path")
                    .attr("d", contextPlot.area(curDataset));

                // update the axes
                d3.select("#focus_xAxis").call(focus_xAxis);
                d3.select("#context_xAxis").call(context_xAxis);
            }


            console.debug("loading csv file...");
            //var fname = "MetaGeekData.csv";
            var fname = "dgData.csv";
            d3.csv(fname, function(data) {
                    var dfieldInfo = preprocessNamedData(data);
                    setCurrentDataset(fname, dfieldInfo, data);
                }
            );


            function brushMove() {
                //console.debug("brushMove()");

                // update the focus x-axis scale
                if (brush.empty()) {
                    focus_xScale.domain(context_xScale.domain());
                } else {
                    focus_xScale.domain(brush.extent());
                }

                // update the focus portion paths
                draw();
            }

            function focusOnMouseMove() {
                //console.debug("focusOnMouseMove");
                var coord = d3.svg.mouse(this);

                // need to threshold before the margin
                if (coord[0] > focusWidth) {
                    return focusOnMouseOut();
                }

                focus.select("#focus_yMouseLine")
                    .attr("display", "inherit")
                    .attr("x1", coord[0])
                    .attr("x2", coord[0]);

                var xDate = focus_xScale.invert(coord[0]);
                focus.select("#focus_yMouseLineText")
                    .attr("x", coord[0] - 4)
                    .text(xDate.toDateString());

                //focusMouseCircles
                //    .attr("display", "inherit")
                //    .attr("cx", coord[0])
                //    .attr("cy", function(d) {
                //            return focusPlots[d].y0 + focusPlots[d].area.y1()[xDate];
                //        });
            }

            function focusOnMouseOut() {
                focus.select("#focus_yMouseLine")
                    .attr("display", "none");
            }
        </script>
    </body>
</html>

